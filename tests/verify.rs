// @generated by build.rs â€” do not edit

use cli::Solution;
use libsql::Builder;
use std::sync::LazyLock;
struct TestEntry {
    input: String,
    expected: String,
    solve: Box<dyn Fn(&str) -> String + Send + Sync>,
}
static ENTRIES: LazyLock<Vec<(u16, u8, u8, TestEntry)>> = LazyLock::new(|| {
    let rt = tokio::runtime::Runtime::new().unwrap();
    let db_path = std::path::Path::new(env!("CARGO_MANIFEST_DIR")).join("aoc.db");
    let db = rt.block_on(Builder::new_local(db_path).build()).unwrap();
    let conn = db.connect().unwrap();
    inventory::iter::<&dyn Solution>
        .into_iter()
        .filter_map(|solution| {
            let year = solution.year();
            let day = solution.day();
            let part = solution.part();
            let mut rows = rt
                .block_on(
                    conn
                        .query(
                            "SELECT input, output FROM solutions WHERE year = ? AND day = ? AND part = ?",
                            (year, day, part),
                        ),
                )
                .ok()?;
            let row = rt.block_on(rows.next()).ok()??;
            let input: String = row.get(0).ok()?;
            let expected: String = row.get(1).ok()?;
            let s: &'static &'static dyn Solution = solution;
            Some((
                year,
                day,
                part,
                TestEntry {
                    input,
                    expected,
                    solve: Box::new(move |input: &str| s.solve(input)),
                },
            ))
        })
        .collect()
});
fn find_entry(year: u16, day: u8, part: u8) -> &'static TestEntry {
    &ENTRIES
        .iter()
        .find(|(y, d, p, _)| *y == year && *d == day && *p == part)
        .unwrap_or_else(|| panic!("no entry for {year}-{day:02}-{part}"))
        .3
}
#[test]
fn y2025_d01_p1() {
    let entry = find_entry(2025, 1, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 1, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d01_p2() {
    let entry = find_entry(2025, 1, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 1, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d02_p1() {
    let entry = find_entry(2025, 2, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 2, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d02_p2() {
    let entry = find_entry(2025, 2, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 2, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d03_p1() {
    let entry = find_entry(2025, 3, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 3, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d03_p2() {
    let entry = find_entry(2025, 3, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 3, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d04_p1() {
    let entry = find_entry(2025, 4, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 4, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d04_p2() {
    let entry = find_entry(2025, 4, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 4, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d05_p1() {
    let entry = find_entry(2025, 5, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 5, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d05_p2() {
    let entry = find_entry(2025, 5, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 5, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d06_p1() {
    let entry = find_entry(2025, 6, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 6, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d06_p2() {
    let entry = find_entry(2025, 6, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 6, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d07_p1() {
    let entry = find_entry(2025, 7, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 7, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d07_p2() {
    let entry = find_entry(2025, 7, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 7, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d08_p1() {
    let entry = find_entry(2025, 8, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 8, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d08_p2() {
    let entry = find_entry(2025, 8, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 8, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d09_p1() {
    let entry = find_entry(2025, 9, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 9, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d09_p2() {
    let entry = find_entry(2025, 9, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 9, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d10_p1() {
    let entry = find_entry(2025, 10, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 10, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d10_p2() {
    let entry = find_entry(2025, 10, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 10, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d11_p1() {
    let entry = find_entry(2025, 11, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 11, 1, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d11_p2() {
    let entry = find_entry(2025, 11, 2);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 11, 2, entry.expected
        .trim(), actual.trim(),
    );
}
#[test]
fn y2025_d12_p1() {
    let entry = find_entry(2025, 12, 1);
    if entry.input.is_empty() || entry.expected.is_empty() {
        return;
    }
    let actual = (entry.solve)(&entry.input);
    assert_eq!(
        actual.trim(), entry.expected.trim(),
        "year {} day {} part {}: expected '{}', got '{}'", 2025, 12, 1, entry.expected
        .trim(), actual.trim(),
    );
}
